Render- 关于Unity渲染方面的优化

如果渲染问题是由GPU瓶颈（GPU bound）引起的

首先，大多数GPU的性能瓶颈问题主要来自于 填充率（fill rate），尤其在移动设备上，其次内存带宽（memory bandwidth）和 顶点处理（vertex processing）也会导致GPU性能瓶颈。

Fill rate

填充率，与GPU每秒可以渲染到屏幕的像素数量有关。如果我们的游戏受到填充率的限制，那么说明我们的游戏每一帧输出到屏幕的像素数量超过了GPU的承载限度。
要检查是否是 填充率 导致的GPU瓶颈方式很简单，运行游戏，在Profiler窗口观察GPU的效率，减小Game窗口的尺寸达到降低窗口分辨率的效果，再运行游戏，观察GPU的效率，如果游戏的表现提升了，那么很可能就是填充率导致的问题。
确定了是填充率导致的，我们可以通过以下几个方面来进行优化：
片元着色器（Fragment Shader）是shader代码块中告诉GPU该如何逐像素渲染的部分，这部分代码是由GPU来执行的，并且每一个像素都会被计算。复杂的片元着色器代码常常是引起填充率问题的根源。

如果我们的游戏使用的是内置shader，我们应该尽可能使用最简单的且最优的shader来达到我们的预期效果。比如，unity的针对移动平台的内置shader，它经过一定的优化。这类shader不但适用移动平台，也适用于其他平台的任何项目。在不失预期效果的前提下，使用”mobile”类的shader是最佳选择。
如果被渲染对象使用的是unity的 标准shader（standard shader），要知道 unity是基于它当前所在的材质面板中的设置来进行编译。而且只有当该材质被使用时shader才被编译。这意味着，通过移除一些材质上的特性比如 detailed maps 会导致片元着色器的计算复杂度降低，即提升性能表现。当然，实际项目中，在不失预期效果的前提下，我们可以通过改变材质的设置来测试是否提升了GPU性能。

Overdraw是当同一个像素被进行多次绘制导致的一种现象。这种现象会产生比较严重的填充率问题。要理解overdraw， 我们必须要知道unity场景中渲染对象的渲染顺序。一个渲染对象的shader决定了它被渲染顺序，通过在shader中设置 渲染队列（render queue）这个属性来改变引擎对其渲染对象的渲染顺序。在不同渲染队列中的对象也是按照不同的顺序进行排列。比如，unity在 几何体队列（Geometry Queue）中，是按照 从前到后（front-to-back）的顺序来对几何体来进行绘制，这样可以最小化overdraw，但是在透明队列（Transparent Queue）中，是按照 从后到前（back-to-front）的顺序来实现屏幕上物体的透明效果。Overdraw的优化是一个比较复杂的话题，没有一个万能的解决方案，但是我们可以通过减少那些无法自动排列的渲染对象的重叠（overlapping）是关键。我们最好从unity的Scene 试图着手研究，在我们编辑器下的Draw Mode里可以让我们看到当前场景中的overdraw情况。

这可以帮我们定位哪些地方可以减少overdraw。其实，产生overdraw的始作俑者主要是透明的材质、未优化的粒子 以及 重叠的UI元素

后处理（PostProcessing）

后处理也是导致填充率问题的关键，尤其是我们使用了超过一种后处理。如果在项目中我们遇到了后处理的问题，我们需要通过进行不同的设置和测试来达到优化的目的（诸如 Bloom等后处理效果）。如果同一个相机上有不止一种后处理效果，这会导致许多pass通道的使用，引起性能瓶颈，这种情况下最好将shader代码中后处理的部分合并到一个pass通道下。如果这样做还是没用，那可能就要考虑不使用这些效果，尤其是在一些低端机上

内存带宽（Memory bandwidth）

内存带宽指的是GPU可以读取和写入的速率。如果遇到内存带宽的问题，常常是由于我们使用了非常大的纹理以至于GPU无法快速的处理它。
如果检查是否是内存带宽的问题，我们可以参考以下步骤：
运行游戏并关注GPU的性能情况
减少纹理的精度，并且可以在Quality Settings中进行相关设置。
再次运行游戏并且关注GPU的性能情况
如果是内存带宽的问题，我们需要减小纹理占用的显存。关于如何优化我们的纹理：

纹理压缩（Texture compression）是一种可以大大减少存储在磁盘上或者内存上的纹理大小的方式。Unity提供许多种不同的纹理压缩的格式以及其对应的设置，来帮助设置纹理的大小。
Mipmaps是一种低分辨率的纹理贴图。当场景中的渲染物体距离相机比较远时，我们可以通过Mipmaps选项来缓解GPU的内存带宽。

顶点处理（Vertex processing）

顶点处理是指GPU在渲染流程中要对网格的每一个顶点进行计算。顶点处理工作的开销主要体现在两个方面：需要被渲染的顶点数量 以及 每一个顶点的计算量。

如果GPU的问题既不是由填充率或 内存带宽引起的，那么很可能就是由于顶点处理工作引起的。

我们可以通过以下方式来对顶点数量以及顶点计算量进行优化：

首先我们需要把目标瞄准减少没有意义的网格顶点。即在游戏中，玩家几乎看不到细节的网格顶点 或者 在生成模型时导致的顶点过多，这些都会无形中给GPU造成多余的开销。在不影响视觉效果的前提下，我们应当尽可能使用顶点数较低的网格。
Unity还提供了法线贴图（normal mapping），这类纹理贴图是用来实现一种几何上的视错觉，让你对网格产生一种立体感。尽管这种技术会对GPU产生一定的消耗，但是它在很多场合收益大于开销。
LOD技术（Level of detail）,它是根据网格距离相机的远近程度来调整模型，相当于是建立一个模型金字塔，根据相机距离模型的位置，对使用的模型进行切换，从而在离相机较远时减少顶点的数量。具体请点击 这里。
顶点着色器是用来告诉GPU该怎么绘制每个顶点。减少我们着色器中顶点部分的计算量也可以有效的提升GPU性能。