在c#中，字符串是引用类型变量而不是值类型变量，即使看起来它是存储字符串的值的。
这就意味着字符串会造成一定的内存垃圾，由于代码中经常使用字符串，所以我们需要对其格外小心。

c#中的字符串是不可变更的，也就是说其内部的值在创建后是不可被变更的。每次在对字符串进行操作的时候（例如运用字符串的“加”操作），
  unity会新建一个字符串用来存储新的字符串，使得旧的字符串被废弃，这样就会造成内存垃圾。

我们可以采用以下的一些方法来最小化字符串的影响：
1）减少不必要的字符串的创建，如果一个字符串被多次利用，我们可以创建并缓存该字符串。
2）减少不必要的字符串操作，例如如果在Text组件中，有一部分字符串需要经常改变，但是其他部分不会，则我们可以将其分为两个部分的组件，
    对于不变的部分就设置为类似常量字符串即可。
3）如果我们需要实时的创建字符串，我们可以采用StringBuilderClass来代替，StringBuilder专为不需要进行内存分配而设计，从而减少字符串产生的内存垃圾。
4）移除游戏中的Debug.Log()函数的代码，尽管该函数可能输出为空，对该函数的调用依然会执行，该函数会创建至少一个字符（空字符）的字符串。
    如果游戏中有大量的该函数的调用，这会造成内存垃圾的增加。
    
在Unity中如果函数需要返回一个数组，则一个新的数组会被分配出来用作结果返回，这不容易被注意到，特别是如果该函数含有迭代器，
  下面的代码中对于每个迭代器都会产生一个新的数组
此外另外的一个函数调用GameObject.name 或者 GameObject.tag也会造成预想不到的堆内存分配，这两个函数都会将结果存为新的字符串返回，
  这就会造成不必要的内存垃圾，对结果进行缓存是一种有效的办法，但是在Unity中都对应的有相关的函数来替代。对于比较gameObject的tag，
  可以采用GameObject.CompareTag()来替代。
装箱操作是非常普遍的一种产生内存垃圾的行为
协程
  调用 StartCoroutine()会产生少量的内存垃圾，因为unity会生成实体来管理协程
  yield在协程中不会产生堆内存分配，但是如果yield带有参数返回，则会造成不必要的内存垃圾
foreach 循环
  在unity5.5以前的版本中，在foreach的迭代中都会生成内存垃圾，主要来自于其后的装箱操作。每次在foreach迭代的时候，都会在堆内存上生产一个System.Object用来实现迭代循环操作。
  在unity5.5中解决了这个问题
